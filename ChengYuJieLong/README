# ğŸ“˜ README â€” æˆè¯­æ¥é¾™er

## Overview

This project is a **prototype web app** for exploring æˆè¯­æ¥é¾™ using a navigable tree interface.

Users input a æˆè¯­ and explore all valid next æˆè¯­ based on configurable strictness rules:

* Toneless pinyin
* Pinyin with tone
* Same character

---

## Core Concepts

### Chengyu as Nodes

Each æˆè¯­ is treated as a node in a directed graph:

```
å¤§å±•å®å›¾ â†’ å›¾ç©·åŒ•è§ â†’ è§ä¹‰å‹‡ä¸º â†’ ...
```

The UI displays one node at a time and its valid outgoing edges.

---

## Strictness Levels

| Strictness      | Matching Rule |
| --------------- | ------------- |
| Toneless Pinyin | da â†’ da       |
| Pinyin          | dÃ  â†’ dÃ        |
| Same Character  | å›¾ â†’ å›¾         |

Strictness affects **only** how the last character matches the next first character.

---

## Data Structure

### Chengyu Type

```ts
type Chengyu = {
  text: string;
  chars: string[];
  pinyin: string[];
  pinyinNoTone: string[];
};
```

---

## Precomputed Lookup Maps

To keep runtime fast, we build **three maps** at startup:

```ts
// Level 1
Map<pinyinNoTone, Chengyu[]>

// Level 2
Map<pinyinWithTone, Chengyu[]>

// Level 3
Map<character, Chengyu[]>
```

### Example

```ts
sameCharMap.get("å›¾") 
â†’ ["å›¾ç©·åŒ•è§", "å›¾æ–‡å¹¶èŒ‚", ...]
```

---

## Tree Generation Logic

```ts
function getNextChengyus(current, strictness) {
  const lastIndex = 3;

  switch (strictness) {
    case 1:
      return tonelessMap.get(current.pinyinNoTone[lastIndex]);
    case 2:
      return pinyinMap.get(current.pinyin[lastIndex]);
    case 3:
      return charMap.get(current.chars[lastIndex]);
  }
}
```

---

## State Management

Only **one step of history** is maintained.

```ts
{
  currentChengyu,
  previousChengyu,
  strictness
}
```

This guarantees:

* Deterministic views
* Easy mental model
* No hidden navigation

---

## UI Behavior

* Clicking a æˆè¯­ recenters the view
* Back button restores the previous æˆè¯­
* Changing strictness recomputes children immediately
* All views are derivable from the current æˆè¯­ + strictness

---

## Backend / Data Source

### Current Approach (Recommended for Prototype)

* Static JSON dictionary
* Loaded at app start
* Indexed in-memory

### Possible Future Improvements

* Server-side expansion
* Frequency-based sorting
* Graph pruning
* Usage statistics

---

## Why This Design Works Well for Learners

* Encourages **pattern recognition**
* Makes pronunciation rules explicit
* Removes pressure of â€œwinningâ€
* Supports curiosity-driven exploration

---

## Future Ideas (Optional)

* Show matching character highlight
* Sort by frequency or HSK level
* Toggle display of pinyin
* Prevent immediate loops
* URL-based deep linking

---

If you want, next I can:

* Help you **design the UI layout**
* Sketch a **React component structure**
* Write the **map-building code**
* Suggest **data formats for your dictionary**
* Help you think about **tree visualization vs list**

Just tell me where you want to go next.
